/* This file is automatically generated. DO NOT EDIT! */

#ifndef _vp_axis_h
#define _vp_axis_h


#include <rsf.h>


void vp_simple_axis (float x1, float y1,     /* starting coordinates */
		     float x2, float y2,     /* ending coordinates */
		     float num1, float num2, /* number range */
		     float onum, float dnum, /* sampling */
		     float ltic              /* tick size */, 
		     char* label             /* axis label */, 
		     float size              /* symbol size */);
/*< Draw an axis.
...
Axis goes from (x1,y1) to (x2,y2) in vplot coordinates
its scale ranges from num1 to num2, ltic is the size of tick marks 
if dnum=0., an optimal linear scale is estimated
>*/


int vp_optimal_scale(int chars                /* characters */, 		
		     bool modify              /* modify the scale */,
		     bool parallel            /* parallel to the axis */,
		     const char* format       /* string format */,
		     float min, float max     /* scale range */, 
		     /*@out@*/ float *onum    /* output origin */,
		     /*@out@*/ float *dnum    /* output scaling */,
		     /*@out@*/ int *maxstrlen /* longest tick label */);
/*< Find an optimal scale. Returns the number of tics >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _vp_coltab_h
#define _vp_coltab_h


void vp_name2coltab (   const char *colname,    /* color table name */
                        int nocol,              /* number of colors */
			/*@out@*/ float *red,             /* RGB values       */
			/*@out@*/ float *green, 
			/*@out@*/ float *blue);
/*< Create a color table. nocol is between 2 and 256. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _vp_contour_h
#define _vp_contour_h


#include <rsf.h>


typedef struct sf_Contour *vp_contour;
/* abstract data type */


vp_contour vp_contour_init(bool transp,                          /* transpose flag */
			   int n1, float o1, float d1, float s1, /* first axis */
			   int n2, float o2, float d2, float s2) /* second axis */;
/*< initialize >*/


void vp_contour_close(vp_contour cnt);
/*< free allocated storage >*/


void vp_contour_draw (vp_contour cnt,
		      bool pos  /* positive only flag */, 
		      float **z /* data to contour */, 
		      float c   /* contour level */);
/*< draw contours >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _vp_gainpar_h
#define _vp_gainpar_h


#include <rsf.h>


void vp_gainpar (sf_file in, float **data, 
		 int n1, int n2 /* panel size */,
		 int step       /* step on the first axis */,
		 float pclip    /* percentage clip */,
		 float phalf    /* percentage for gpow */,
		 float *clip    /* output clip */, 
		 float *gpow    /* output gpow */, 
		 bool mean      /* set bias to mean */,
		 float *bias, 
		 int n3         /* number of panels */ ,
		 int panel      /* gain type */,
		 int cpanel     /* current panel */);
/*< Find clip and gpow parameters >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _vp_plot_h
#define _vp_plot_h


void vp_set_dash (float type
/*
 *	0 continuous   DEFAULT
 *	1 fine dash
 *	2 fine dot
 *	3 dash
 *	4 large dash
 *	5 dot dash
 *	6 large dash small dash
 *	7 double dot
 *	8 double dash
 *	9 loose dash  The part after the decimal point determines 
 *                     the pattern repetition interval
 */);
/*< set dash type >*/


void vp_plot_init(int n2 /* number of lines */);
/*< initialize vector plot >*/


void vp_plot_set (int i2 /* line number */);
/*< select a line >*/


void vp_plot_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _vp_stdplot_h
#define _vp_stdplot_h


#include <rsf.h>


void vp_stdplot_init (float umin1, float umax1 /* user's frame for axis 1 */, 
		      float umin2, float umax2 /* user's frame for axis 2 */,
		      bool transp1             /* default transpose flag */, 
		      bool xreverse1           /* default x reverse flag */, 
		      bool yreverse1           /* default y reverse flag */, 
		      bool pad1                /* default padding */);
/*< Initializing standard plot >*/


void vp_cubecoord (int side /* 1=top, 2=side, 3=front */,
		   float umin1, float umax1, float umin2, float umax2);
/*< setup the coordinate system for the cube front >*/


void vp_coordinates (void);
/*< setup the coordinate system >*/


void vp_cubeplot_init (int n1pix, int n2pix,      /* total pixels */ 
		       int n1front, int n2front,  /* front face pixels */
		       bool flat1                 /* flat flag */,
                       bool movie1                /* movie flag */);
/*< Initializing 3-D cube plot. >*/


void vp_frame_init (sf_file in        /* input file */, 
		    const char* where /* three chars: label1, label2, title */,
		    bool grid         /* grid flag */);
/*< Initializing generic frame >*/


void vp_barframe_init (sf_file in, float min, float max);
/*< Initializing bar label frame >*/


void vp_plot_unset (void);
/*< return to defaults >*/


void vp_simpleframe(void);
/*< Drawing simple frame >*/


void vp_framenum(float num);
/*< Outputting frame number >*/


void vp_simplebarframe (void);
/*< Drawing simple frame for the bar label >*/


void vp_frame(void);
/*< Drawing frame >*/


void vp_barframe(void);
/*< Drawing bar label frame >*/


void vp_barraster (int nbuf, unsigned char** buf /* buf[1][nbuf] */);
/*< Filling bar label with rasters >*/


void vp_cuberaster(int n1, int n2, 
		   unsigned char** buf      /* buf[n2][n1] */ , 
		   int f1, int f2, int f3   /* frame numbers */);
/*< Filling 3-D cube with rasters >*/


void vp_cubeframe(float f1, float f2, float f3   /* frame numbers */);
/*< Drawing 3-D frame >*/


void vp_barline (int nc     /* number of contours */, 
		 float *c   /* contours [nc] */, 
		 float cmin /* minimum value */, 
		 float cmax /* maximum value */);
/*< Drawing contour lines in a bar label >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _vp_vplot_h
#define _vp_vplot_h


#define VP_SCREEN_RATIO 0.75 
/* aspect ratio, default window */
#define VP_ROTATED_HEIGHT 7.5
/* height in inches, rotated */    
#define VP_STANDARD_HEIGHT 10.24
/* height in inches, default device */ 
#define VP_MAX 54.6           
/* absolute maximum x or y in inches */
#define VP_BSIZE 256
/* number of pixels for scalebars */


enum {
    RPERIN=600,         /* vplot units per inch */
    HATCHPERIN=100,	/* Hatch units per inch */
    TXPERIN=33,	        /* Text units per inch */
    FATPERIN=200,	/* Fatness units per inch */
    MAX_GUN=255,	/* Maximum color gun strength */
    /*
     * This is the factor we scale our path and up vectors by before
     * running them through the local text coordinate transformation.
     * (The coordinate transformation, being in terms of device units,
     * gets done in integers. If we don't scale up we get severe roundoff
     * problems for small text sizes at odd angles. We can't make this
     * factor too big, though, or we risk very large text overflowing
     * the maximum possible integer.)
     */
    TEXTVECSCALE=10
};


enum {PEN, ROMANS, ROMAND, ROMANC, ROMANT, ITALICC, ITALICT, 
      SCRIPTS, SCRIPTC, GREEKS, GREEKC, CYRILC, GOTHGBT, GOTHGRT, GOTHITT,
      MATH, MISC};


enum {
    TH_NORMAL, /* Use the default */
    TH_LEFT,   /* Left justify */
    TH_CENTER, /* Center */
    TH_RIGHT,  /* Right justify */
    TH_SYMBOL  /* Position the character for use as a marking point */
};
enum {
    TV_NORMAL, /* Use the default */
    TV_BOTTOM, /* Bottom of writing area */
    TV_BASE,   /* Bottom of capital letters */
    TV_HALF,   /* Centered */
    TV_CAP,    /* Top of capital letters */
    TV_TOP,    /* Top of writing area */
    TV_SYMBOL  /* Position the character for use as a marking point */
};


enum {
    VP_SETSTYLE         = 'S',
    VP_MOVE             = 'm',
    VP_DRAW	        = 'd',
    VP_PLINE	    	= 'L',
    VP_PMARK	   	= 'M',
    VP_TEXT		= 'T',
    VP_GTEXT		= 'G',
    VP_AREA		= 'A',
    VP_OLDAREA		= 'a',
    VP_BYTE_RASTER	= 'R',
    VP_BIT_RASTER	= 'r',    
    VP_ERASE		= 'e',
    VP_BREAK		= 'b',
    VP_PURGE		= 'p',
    VP_NOOP		= 'n',    
    VP_ORIGIN		= 'o',
    VP_WINDOW		= 'w',    
    VP_FAT		= 'f',
    VP_SETDASH		= 's',
    VP_COLOR		= 'c',
    VP_SET_COLOR_TABLE	= 'C',
    VP_TXALIGN		= 'J',
    VP_TXFONTPREC	= 'F',
    VP_PATLOAD		= 'l',
    VP_OVERLAY		= 'v',    
    VP_MESSAGE		= 'z',
    VP_BEGIN_GROUP	= '[',
    VP_END_GROUP	= ']',    
    VP_OLDTEXT		= 't',
    VP_BACKGROUND       = 'E'
};


typedef enum {
    VP_NO_STYLE_YET=-1,
    VP_STANDARD, /* Origin in lower left, scaled so that the maximum Y	value
		    (top of  the  screen)  is VP_STANDARD_HEIGHT */
    VP_ROTATED, /* Origin in upper left, Y-axis horizontal increasing
		   to the right, X-axis vertical and increasing down,
		   scaled so that the maximum X value (bottom of  the
		   screen)  is VP_ROTATED_HEIGHT.  Use is discouraged */
    VP_OLD,
    VP_ABSOLUTE /* Origin  in  lower left, plotted in physical inches
		   on the device */
} vp_plotstyle;


enum {
    VP_BLACK,
    VP_BLUE,
    VP_RED,
    VP_PURPLE,
    VP_GREEN,
    VP_CYAN,
    VP_YELLOW,
    VP_WHITE
};


enum {
    VP_NO_CHANGE=-1, /* Use the previous value. */
    VP_STRING,       /* Use the hardware  text  capabilities  to
			write the whole string. */
    VP_CHAR,         /* Use hardware  characters,	but  position
			them individually. */
    VP_STROKE        /* Software text. */
};


enum {
    OVLY_NORMAL,    /* draw the text over */
    OVLY_BOX,       /* draw a box around the text */
    OVLY_SHADE,     /* clear a box under the text */
    OVLY_SHADE_BOX  /* box the text and clear under it */
};    
/* text overlay */


void vp_filep(FILE *file);
/*< set the output file >*/


void vp_init(void);
/*< Initialize output to vplot >*/


int vp_getint (void);
/*< Extract and decode an integer >*/


void vp_putint (int w);
/*< Output an encoded integer >*/


void vp_putfloat (float w);
/*< Output an encoded float with scaling >*/


void vp_putfloat0 (float w);
/*< Output an encoded float without scaling >*/


void vp_egroup (void);
/*< end group >*/


void vp_erase (void);
/*< erase screen >*/


void vp_background (void);
/*< erase screen to the background color  >*/


void vp_fat (int f);
/*< set line width >*/


void vp_fill (const float *xp /* [np] */, 
	      const float *yp /* [np] */, 
	      int  np         /* number of points */);
/*< fill polygon >*/


void vp_ufill (const float *xp /* [np] */, 
	       const float *yp /* [np] */, 
	       int  np         /* number of points */);
/*< fill polygon defined in user coordinates >*/


void vp_area (const float *xp, const float *yp /* points [np] */,
	      int np                           /* number of points */,
	      int fat                          /* fatness of the border line */, 
	      int xmask, int ymask             /* rectangles for filling
						  (1,1 - solid fill;
						  1,2 - horizontal lines;
						  0,1 - not filled;
						  4,4 - gray color) */);
/*< Fill the aread (old-style polygon) >*/


void vp_uarea (const float *xp, const float *yp, int np, 
	       int fat, int xmask, int ymask);
/*< old-style polygon defined in user coordinates >*/


void vp_coltab (int color /* color index */, 
		float r   /* red */, 
		float g   /* green */, 
		float b   /* blue */);
/*< set a color table entry >*/


void vp_gtext (float x, float y         /* reference point */, 
	       float xpath, float ypath /* vector pointing for the string */,
	       float xup, float yup     /* vector pointing in the ‘‘up’’ 
					   direction  for  individual letters */, 
	       const char *string);
/*< output text string using the currently-defined font, 
  precision,  and text  alignment >*/


void vp_ugtext (float x, float y, 
		float xpath, float ypath,
		float xup, float yup, const char *string);
/*< output text string in user coordinates >*/


void vp_hatchload (int angle  /* line angle */,
		   int nhatch /* number of lines */, 
		   int ihatch /* pattern number */, 
		   int *hatch /* [2 * 4 * nhatch]  for each  set  of	lines
				 (nhatch * 2) contains 4 elements for
				 ‘fatness’, ‘color’, ‘offset’, ‘repeat interval’ */);
/*< Load a hatch pattern  >*/


void vp_message (const char *string);
/*< output message >*/


void vp_move (float x,float  y);
/*< move to a point >*/


void vp_umove (float x,float  y);
/*< move to a point in user coordinates >*/


void vp_orig (float x,float  y);
/*< set the origin >*/


void vp_uorig (float x,float  y);
/*< set the origin in user coordinates >*/


void vp_patload (int ppi          /* pixels per inch */, 
		 int  nx, int ny  /* dimensions */,
		 int ipat         /* pattern number */, 
		 int *col         /* [nx * ny] pattern (color table numbers) */);
/*<Load a raster pattern  >*/


void vp_pendn (float x, float y);
/*< go to location (x,y) and then put the pen down >*/


void vp_upendn (float x, float y);
/*< go to location (x,y) in user coordinates and then put the pen down >*/


void vp_penup (void);
/*< put pen up >*/


void vp_pline (const float *xp /* [np] */, 
	       const float *yp /* [np] */, 
	       int np          /* number of points */);
/*< draw a line >*/


void vp_upline (const float *xp /* [np] */, 
		const float *yp /* [np] */, 
		int np          /* number of points */);
/*< draw a line in user coordinates >*/


void vp_plot (float x, float y, bool  down);
/*< line drawing >*/


void vp_uplot (float x, float y, bool down);
/*< line drawing in user coordinates >*/


void vp_draw (float x,float  y);
/*< line drawing step >*/


void vp_udraw (float x,float  y);
/*< line drawing step in user coordinates >*/


void vp_pmark (int npts, int mtype, int msize, 
	       const float *xp, const float *yp);
/*< Plot polymarkers >*/


void vp_purge (void);
/*< Flush the output >*/


void vp_rascoltab (int nreserve, const char *colname);
/*< set a raster color table >*/


void vp_raster (unsigned char **array, 
		bool bit               /* one bit/byte per pixel */, 
		int offset             /* add offset for bytes */, 
		int xpix, int ypix     /* number of pixels */, 
		float xll, float yll, 
		float xur,float yur    /* display coordinates */, int orient);
/*< Output a raster array >*/


void vp_uraster (unsigned char **array, bool bit, int offset,
		 int xpix, int ypix, 
		 float xll, float yll, float xur, float yur, int orient);
/*< Output a raster array in user coordinates >*/


void vp_scale (float xscale, float  yscale);
/*< set scaling >*/


void vp_stretch (float xmin, float ymin, float xmax, float ymax);
/*< set scale and origin for a rectangular area >*/


void vp_style (vp_plotstyle st);
/*< set vpplot style >*/


void vp_text (float x, float y    /* coordinate of the reference point */, 
	      int size            /* height of character */, 
	      int orient          /* text drawing direction ( in degrees counter-clockwise
				     from horizontal, right-facing) */, 
	      const char *string /* test */);
/*< output text string >*/


void vp_utext (float x, float y, int size, int orient, const char *string);
/*< output text string in user coordinates >*/


void vp_tfont (int font1 /* which font to use */, 
	       int prec1 /* font precision */, 
	       int ovly1 /* overlay mode */);
/*< set text font >*/


void vp_tjust (int xjust1, int yjust1);
/*< set text alignment >*/


void vp_clip (float xmin, float ymin, float xmax, float ymax);
/*< set rectangular clip >*/


void vp_uclip (float xmin, float ymin, float xmax, float ymax);
/*< set rectangular clip in user coordinates >*/


void vp_where (float *x, float *y);
/*< output current pen location >*/


void vp_color (int col);
/*< set drawing color >*/


void vp_arrow (float x1, float y1 /* starting point */, 
	       float x, float y   /* end point */, 
	       float r            /* arrow size */);
/*< plot an arrow >*/


void vp_uarrow (float x1, float y1, float x, float y, float r);
/*< plot an arrow in user coordinates >*/


void vp_dash (float dash1, float gap1, float dash2, float gap2);
/*< set dash pattern >*/


void vp_setdash (const float *dash, const float *gapp, int np);
/*< set dash pattern >*/


void vp_bgroup(const char *string /* group name */);
/*< begin group >*/


void vp_break(void);
/*< Interrupt the output processing >*/

#endif
