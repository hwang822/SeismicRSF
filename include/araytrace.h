/* This file is automatically generated. DO NOT EDIT! */

#ifndef _araytrace_h
#define _araytrace_h


typedef struct aRayTrace* araytrace;
/* abstract data type */


araytrace araytrace_init(int dim            /* dimensionality (2 or 3) */, 
			 int nt             /* number of ray tracing steps */, 
			 float dt           /* ray tracing step (in time) */,
			 int* n             /* velocity dimensions [dim] */, 
			 float* o, float* d /* velocity grid [dim] */,
			 float* vz2         /* vertical velocity squared [n3*n2*n1] */, 
			 float* vx2         /* horizontal velocity squared [n3*n2*n1] */,
			 float* q           /* anallepticity [n3*n2*n1] */,
			 int order          /* interpolation order */);
/*< Initialize ray tracing object. 
 * Increasing order increases accuracy but
 decreases efficiency. Recommended values: 3 or 4.
 * vz2, vx2, and q can be changed or deallocated after
 araytrace_init.
 >*/


void araytrace_close (araytrace rt);
/*< Free internal storage >*/


int trace_aray (araytrace rt  /* ray tracing object */, 
		float* x      /* point location {z,y,x} [dim] */, 
		float* p      /* ray parameter vector [dim] */, 
		float** traj  /* output ray trajectory [nt+1,dim] */);
/*< Trace a ray.
 * Values of x and p are changed inside the function.
 * The trajectory traj is stored as follows:
 {z0,y0,z1,y1,z2,y2,...} in 2-D
 {z0,y0,x0,z1,y1,x1,...} in 3-D
 * Vector p points in the direction of the ray. 
 The length of the vector is not important.
 Example initialization:
 p[0] = cos(a); p[1] = sin(a) in 2-D, a is between 0 and 2*pi radians
 p[0] = cos(b); p[1] = sin(b)*cos(a); p[2] = sin(b)*sin(a) in 3-D
 b is inclination between 0 and   pi radians
 a is azimuth     between 0 and 2*pi radians
 * The output code for it = trace_ray(...)
 it=0 - ray traced to the end without leaving the grid
 it>0 - ray exited at the top of the grid
 it<0 - ray exited at the side or bottom of the grid
 * The total traveltime along the ray is 
 nt*dt if (it = 0); abs(it)*dt otherwise 
 >*/

#endif
